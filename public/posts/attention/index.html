<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Attention | Sage&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="此处提供一张思维导图。

(Generated by NoteBookLLM)
为什么需要注意力机制
传统的 Seq2Seq 模型(此处以 RNN 的 Encoder - Decoder 模型为例)，会将输入序列压缩为一个定长的向量，解码器再从这个向量生成输出序列。但是定长的向量难以有效编码所有必要的信息，那么就成为了处理长句子的瓶颈。
注意力机制的具体运作
注意力机制将输入编码成一个向量序列(annotations)。在生成输出序列的每个词的时候，模型会软搜索输入序列中的相关位置，根据这些相关的上下文向量和之前已经生成的目标词来预测下一个目标词。
缩放点积注意力(SDPA)
$$
Atten(Q,K,V)=softmax\left( \frac{QK^T}{\sqrt{ d_{k} }} \right)V \tag{1}
$$

注意力机制的核心在于计算一个上下文向量$(Atten(Q,K,V))$，这个向量是输入序列的加权和，权重反应了输入序列中每个部分对于生成序列当前输出词的重要性。
在Scaled Dot-Product Attention 中，首先计算 query 和 key 的关联性，然后将这个关联性作为value 的权重，各个权重与 value 的乘积相加得到输出。(公式 1)
$\sqrt{ d_{k} }$作用是缩放注意力分数。因为当$d_{k}$很大的时候，点积$QK^T$的结果会很大，导致 Softmax 产生极度不均匀的分布，梯度会变得很小。

import torch
import torch.nn as nn

class ScaledDotProductAttention(nn.Module):
    def __init__(self):
        super(ScaledDotProductAttention, self).__init__()
        
    def forward(self, query, key, value, causal_mask=None,padding_mask=None):
        &#34;&#34;&#34;
        Single-head Scaled Dot-Product Attention
        Args:
            query: Query tensor of shape (batch_size, seq_len_q, d_k)
            key: Key tensor of shape (batch_size, seq_len_k, d_k)
            value: Value tensor of shape (batch_size, seq_len_v, d_v)
            causal_mask: Optional causal mask tensor of shape (batch_size, seq_len_q, seq_len_k)
            padding_mask: Optional padding mask tensor of shape (batch_size, seq_len_q, seq_len_k)
            1. Causal mask is used to prevent attending to future tokens in the sequence.
            2. Padding mask is used to ignore padding tokens in the sequence.
            3. Both masks are optional and can be None.
        Returns:
            attention_output: Attention weighted output tensor of shape (batch_size, seq_len_q, d_v)
        &#34;&#34;&#34;
        d_k = query.size(-1) # Hidden size of the key/query
        attention_scores = torch.matmul(query,key.transpose(-1,-2)) / torch.sqrt(torch.tensor(d_k,dtype=torch.float32))
        if causal_mask is not None:
            attention_scores = attention_scores.masked_fill(causal_mask == 0, float(&#39;-inf&#39;))
        if padding_mask is not None:
            attention_scores = attention_scores.masked_fill(padding_mask == 0, float(&#39;-inf&#39;))
        
        attention_weights = torch.softmax(attention_scores, dim=-1)
        attention_output = torch.matmul(attention_weights, value)
        
        return attention_output


def test():
    batch_size = 8
    seq_len = 16
    hidden_size = 64

    query = torch.randn(batch_size,seq_len,hidden_size)
    key = torch.randn(batch_size,seq_len,hidden_size)
    value = torch.randn(batch_size,seq_len,hidden_size)
    sdpa = ScaledDotProductAttention()
    output = sdpa(query, key, value)
    
    print(&#34;Query shape:&#34;, query.shape)
    print(&#34;Key shape:&#34;, key.shape)
    print(&#34;Value shape:&#34;, value.shape)
    print(&#34;Output shape:&#34;, output.shape)

if __name__ == &#34;__main__&#34;:
    test()
多头注意力
Transformer 是完全基于注意力机制的新架构，放弃了循环和卷积，使用多头注意力(Multi-Head Attention)(MHA)。">
<meta name="author" content="Sage">
<link rel="canonical" href="http://localhost:1313/posts/attention/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/assets/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/attention/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
    integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"
    crossorigin="anonymous"
    referrerpolicy="no-referrer">

<script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"
    integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
    type="text/javascript"></script>

<script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
    type="text/javascript"></script>

<script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "\\[", right: "\\]", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
      ],
    });
  });
</script>


<meta property="og:url" content="http://localhost:1313/posts/attention/">
  <meta property="og:site_name" content="Sage&#39;s Blog">
  <meta property="og:title" content="Attention">
  <meta property="og:description" content="此处提供一张思维导图。 (Generated by NoteBookLLM)
为什么需要注意力机制 传统的 Seq2Seq 模型(此处以 RNN 的 Encoder - Decoder 模型为例)，会将输入序列压缩为一个定长的向量，解码器再从这个向量生成输出序列。但是定长的向量难以有效编码所有必要的信息，那么就成为了处理长句子的瓶颈。
注意力机制的具体运作 注意力机制将输入编码成一个向量序列(annotations)。在生成输出序列的每个词的时候，模型会软搜索输入序列中的相关位置，根据这些相关的上下文向量和之前已经生成的目标词来预测下一个目标词。
缩放点积注意力(SDPA) $$ Atten(Q,K,V)=softmax\left( \frac{QK^T}{\sqrt{ d_{k} }} \right)V \tag{1} $$
注意力机制的核心在于计算一个上下文向量$(Atten(Q,K,V))$，这个向量是输入序列的加权和，权重反应了输入序列中每个部分对于生成序列当前输出词的重要性。 在Scaled Dot-Product Attention 中，首先计算 query 和 key 的关联性，然后将这个关联性作为value 的权重，各个权重与 value 的乘积相加得到输出。(公式 1) $\sqrt{ d_{k} }$作用是缩放注意力分数。因为当$d_{k}$很大的时候，点积$QK^T$的结果会很大，导致 Softmax 产生极度不均匀的分布，梯度会变得很小。 import torch import torch.nn as nn class ScaledDotProductAttention(nn.Module): def __init__(self): super(ScaledDotProductAttention, self).__init__() def forward(self, query, key, value, causal_mask=None,padding_mask=None): &#34;&#34;&#34; Single-head Scaled Dot-Product Attention Args: query: Query tensor of shape (batch_size, seq_len_q, d_k) key: Key tensor of shape (batch_size, seq_len_k, d_k) value: Value tensor of shape (batch_size, seq_len_v, d_v) causal_mask: Optional causal mask tensor of shape (batch_size, seq_len_q, seq_len_k) padding_mask: Optional padding mask tensor of shape (batch_size, seq_len_q, seq_len_k) 1. Causal mask is used to prevent attending to future tokens in the sequence. 2. Padding mask is used to ignore padding tokens in the sequence. 3. Both masks are optional and can be None. Returns: attention_output: Attention weighted output tensor of shape (batch_size, seq_len_q, d_v) &#34;&#34;&#34; d_k = query.size(-1) # Hidden size of the key/query attention_scores = torch.matmul(query,key.transpose(-1,-2)) / torch.sqrt(torch.tensor(d_k,dtype=torch.float32)) if causal_mask is not None: attention_scores = attention_scores.masked_fill(causal_mask == 0, float(&#39;-inf&#39;)) if padding_mask is not None: attention_scores = attention_scores.masked_fill(padding_mask == 0, float(&#39;-inf&#39;)) attention_weights = torch.softmax(attention_scores, dim=-1) attention_output = torch.matmul(attention_weights, value) return attention_output def test(): batch_size = 8 seq_len = 16 hidden_size = 64 query = torch.randn(batch_size,seq_len,hidden_size) key = torch.randn(batch_size,seq_len,hidden_size) value = torch.randn(batch_size,seq_len,hidden_size) sdpa = ScaledDotProductAttention() output = sdpa(query, key, value) print(&#34;Query shape:&#34;, query.shape) print(&#34;Key shape:&#34;, key.shape) print(&#34;Value shape:&#34;, value.shape) print(&#34;Output shape:&#34;, output.shape) if __name__ == &#34;__main__&#34;: test() 多头注意力 Transformer 是完全基于注意力机制的新架构，放弃了循环和卷积，使用多头注意力(Multi-Head Attention)(MHA)。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-31T22:48:40+08:00">
    <meta property="article:modified_time" content="2025-05-31T22:48:40+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Attention">
<meta name="twitter:description" content="此处提供一张思维导图。

(Generated by NoteBookLLM)
为什么需要注意力机制
传统的 Seq2Seq 模型(此处以 RNN 的 Encoder - Decoder 模型为例)，会将输入序列压缩为一个定长的向量，解码器再从这个向量生成输出序列。但是定长的向量难以有效编码所有必要的信息，那么就成为了处理长句子的瓶颈。
注意力机制的具体运作
注意力机制将输入编码成一个向量序列(annotations)。在生成输出序列的每个词的时候，模型会软搜索输入序列中的相关位置，根据这些相关的上下文向量和之前已经生成的目标词来预测下一个目标词。
缩放点积注意力(SDPA)
$$
Atten(Q,K,V)=softmax\left( \frac{QK^T}{\sqrt{ d_{k} }} \right)V \tag{1}
$$

注意力机制的核心在于计算一个上下文向量$(Atten(Q,K,V))$，这个向量是输入序列的加权和，权重反应了输入序列中每个部分对于生成序列当前输出词的重要性。
在Scaled Dot-Product Attention 中，首先计算 query 和 key 的关联性，然后将这个关联性作为value 的权重，各个权重与 value 的乘积相加得到输出。(公式 1)
$\sqrt{ d_{k} }$作用是缩放注意力分数。因为当$d_{k}$很大的时候，点积$QK^T$的结果会很大，导致 Softmax 产生极度不均匀的分布，梯度会变得很小。

import torch
import torch.nn as nn

class ScaledDotProductAttention(nn.Module):
    def __init__(self):
        super(ScaledDotProductAttention, self).__init__()
        
    def forward(self, query, key, value, causal_mask=None,padding_mask=None):
        &#34;&#34;&#34;
        Single-head Scaled Dot-Product Attention
        Args:
            query: Query tensor of shape (batch_size, seq_len_q, d_k)
            key: Key tensor of shape (batch_size, seq_len_k, d_k)
            value: Value tensor of shape (batch_size, seq_len_v, d_v)
            causal_mask: Optional causal mask tensor of shape (batch_size, seq_len_q, seq_len_k)
            padding_mask: Optional padding mask tensor of shape (batch_size, seq_len_q, seq_len_k)
            1. Causal mask is used to prevent attending to future tokens in the sequence.
            2. Padding mask is used to ignore padding tokens in the sequence.
            3. Both masks are optional and can be None.
        Returns:
            attention_output: Attention weighted output tensor of shape (batch_size, seq_len_q, d_v)
        &#34;&#34;&#34;
        d_k = query.size(-1) # Hidden size of the key/query
        attention_scores = torch.matmul(query,key.transpose(-1,-2)) / torch.sqrt(torch.tensor(d_k,dtype=torch.float32))
        if causal_mask is not None:
            attention_scores = attention_scores.masked_fill(causal_mask == 0, float(&#39;-inf&#39;))
        if padding_mask is not None:
            attention_scores = attention_scores.masked_fill(padding_mask == 0, float(&#39;-inf&#39;))
        
        attention_weights = torch.softmax(attention_scores, dim=-1)
        attention_output = torch.matmul(attention_weights, value)
        
        return attention_output


def test():
    batch_size = 8
    seq_len = 16
    hidden_size = 64

    query = torch.randn(batch_size,seq_len,hidden_size)
    key = torch.randn(batch_size,seq_len,hidden_size)
    value = torch.randn(batch_size,seq_len,hidden_size)
    sdpa = ScaledDotProductAttention()
    output = sdpa(query, key, value)
    
    print(&#34;Query shape:&#34;, query.shape)
    print(&#34;Key shape:&#34;, key.shape)
    print(&#34;Value shape:&#34;, value.shape)
    print(&#34;Output shape:&#34;, output.shape)

if __name__ == &#34;__main__&#34;:
    test()
多头注意力
Transformer 是完全基于注意力机制的新架构，放弃了循环和卷积，使用多头注意力(Multi-Head Attention)(MHA)。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Attention",
      "item": "http://localhost:1313/posts/attention/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Attention",
  "name": "Attention",
  "description": "此处提供一张思维导图。 (Generated by NoteBookLLM)\n为什么需要注意力机制 传统的 Seq2Seq 模型(此处以 RNN 的 Encoder - Decoder 模型为例)，会将输入序列压缩为一个定长的向量，解码器再从这个向量生成输出序列。但是定长的向量难以有效编码所有必要的信息，那么就成为了处理长句子的瓶颈。\n注意力机制的具体运作 注意力机制将输入编码成一个向量序列(annotations)。在生成输出序列的每个词的时候，模型会软搜索输入序列中的相关位置，根据这些相关的上下文向量和之前已经生成的目标词来预测下一个目标词。\n缩放点积注意力(SDPA) $$ Atten(Q,K,V)=softmax\\left( \\frac{QK^T}{\\sqrt{ d_{k} }} \\right)V \\tag{1} $$\n注意力机制的核心在于计算一个上下文向量$(Atten(Q,K,V))$，这个向量是输入序列的加权和，权重反应了输入序列中每个部分对于生成序列当前输出词的重要性。 在Scaled Dot-Product Attention 中，首先计算 query 和 key 的关联性，然后将这个关联性作为value 的权重，各个权重与 value 的乘积相加得到输出。(公式 1) $\\sqrt{ d_{k} }$作用是缩放注意力分数。因为当$d_{k}$很大的时候，点积$QK^T$的结果会很大，导致 Softmax 产生极度不均匀的分布，梯度会变得很小。 import torch import torch.nn as nn class ScaledDotProductAttention(nn.Module): def __init__(self): super(ScaledDotProductAttention, self).__init__() def forward(self, query, key, value, causal_mask=None,padding_mask=None): \u0026#34;\u0026#34;\u0026#34; Single-head Scaled Dot-Product Attention Args: query: Query tensor of shape (batch_size, seq_len_q, d_k) key: Key tensor of shape (batch_size, seq_len_k, d_k) value: Value tensor of shape (batch_size, seq_len_v, d_v) causal_mask: Optional causal mask tensor of shape (batch_size, seq_len_q, seq_len_k) padding_mask: Optional padding mask tensor of shape (batch_size, seq_len_q, seq_len_k) 1. Causal mask is used to prevent attending to future tokens in the sequence. 2. Padding mask is used to ignore padding tokens in the sequence. 3. Both masks are optional and can be None. Returns: attention_output: Attention weighted output tensor of shape (batch_size, seq_len_q, d_v) \u0026#34;\u0026#34;\u0026#34; d_k = query.size(-1) # Hidden size of the key/query attention_scores = torch.matmul(query,key.transpose(-1,-2)) / torch.sqrt(torch.tensor(d_k,dtype=torch.float32)) if causal_mask is not None: attention_scores = attention_scores.masked_fill(causal_mask == 0, float(\u0026#39;-inf\u0026#39;)) if padding_mask is not None: attention_scores = attention_scores.masked_fill(padding_mask == 0, float(\u0026#39;-inf\u0026#39;)) attention_weights = torch.softmax(attention_scores, dim=-1) attention_output = torch.matmul(attention_weights, value) return attention_output def test(): batch_size = 8 seq_len = 16 hidden_size = 64 query = torch.randn(batch_size,seq_len,hidden_size) key = torch.randn(batch_size,seq_len,hidden_size) value = torch.randn(batch_size,seq_len,hidden_size) sdpa = ScaledDotProductAttention() output = sdpa(query, key, value) print(\u0026#34;Query shape:\u0026#34;, query.shape) print(\u0026#34;Key shape:\u0026#34;, key.shape) print(\u0026#34;Value shape:\u0026#34;, value.shape) print(\u0026#34;Output shape:\u0026#34;, output.shape) if __name__ == \u0026#34;__main__\u0026#34;: test() 多头注意力 Transformer 是完全基于注意力机制的新架构，放弃了循环和卷积，使用多头注意力(Multi-Head Attention)(MHA)。\n",
  "keywords": [
    
  ],
  "articleBody": "此处提供一张思维导图。 (Generated by NoteBookLLM)\n为什么需要注意力机制 传统的 Seq2Seq 模型(此处以 RNN 的 Encoder - Decoder 模型为例)，会将输入序列压缩为一个定长的向量，解码器再从这个向量生成输出序列。但是定长的向量难以有效编码所有必要的信息，那么就成为了处理长句子的瓶颈。\n注意力机制的具体运作 注意力机制将输入编码成一个向量序列(annotations)。在生成输出序列的每个词的时候，模型会软搜索输入序列中的相关位置，根据这些相关的上下文向量和之前已经生成的目标词来预测下一个目标词。\n缩放点积注意力(SDPA) $$ Atten(Q,K,V)=softmax\\left( \\frac{QK^T}{\\sqrt{ d_{k} }} \\right)V \\tag{1} $$\n注意力机制的核心在于计算一个上下文向量$(Atten(Q,K,V))$，这个向量是输入序列的加权和，权重反应了输入序列中每个部分对于生成序列当前输出词的重要性。 在Scaled Dot-Product Attention 中，首先计算 query 和 key 的关联性，然后将这个关联性作为value 的权重，各个权重与 value 的乘积相加得到输出。(公式 1) $\\sqrt{ d_{k} }$作用是缩放注意力分数。因为当$d_{k}$很大的时候，点积$QK^T$的结果会很大，导致 Softmax 产生极度不均匀的分布，梯度会变得很小。 import torch import torch.nn as nn class ScaledDotProductAttention(nn.Module): def __init__(self): super(ScaledDotProductAttention, self).__init__() def forward(self, query, key, value, causal_mask=None,padding_mask=None): \"\"\" Single-head Scaled Dot-Product Attention Args: query: Query tensor of shape (batch_size, seq_len_q, d_k) key: Key tensor of shape (batch_size, seq_len_k, d_k) value: Value tensor of shape (batch_size, seq_len_v, d_v) causal_mask: Optional causal mask tensor of shape (batch_size, seq_len_q, seq_len_k) padding_mask: Optional padding mask tensor of shape (batch_size, seq_len_q, seq_len_k) 1. Causal mask is used to prevent attending to future tokens in the sequence. 2. Padding mask is used to ignore padding tokens in the sequence. 3. Both masks are optional and can be None. Returns: attention_output: Attention weighted output tensor of shape (batch_size, seq_len_q, d_v) \"\"\" d_k = query.size(-1) # Hidden size of the key/query attention_scores = torch.matmul(query,key.transpose(-1,-2)) / torch.sqrt(torch.tensor(d_k,dtype=torch.float32)) if causal_mask is not None: attention_scores = attention_scores.masked_fill(causal_mask == 0, float('-inf')) if padding_mask is not None: attention_scores = attention_scores.masked_fill(padding_mask == 0, float('-inf')) attention_weights = torch.softmax(attention_scores, dim=-1) attention_output = torch.matmul(attention_weights, value) return attention_output def test(): batch_size = 8 seq_len = 16 hidden_size = 64 query = torch.randn(batch_size,seq_len,hidden_size) key = torch.randn(batch_size,seq_len,hidden_size) value = torch.randn(batch_size,seq_len,hidden_size) sdpa = ScaledDotProductAttention() output = sdpa(query, key, value) print(\"Query shape:\", query.shape) print(\"Key shape:\", key.shape) print(\"Value shape:\", value.shape) print(\"Output shape:\", output.shape) if __name__ == \"__main__\": test() 多头注意力 Transformer 是完全基于注意力机制的新架构，放弃了循环和卷积，使用多头注意力(Multi-Head Attention)(MHA)。\nMHA 的基本思想是并行地执行多次注意力函数(SDPA)。\n好处是允许模型在不同的表示子空间中共同关注来自不同位置的信息 只是用一个注意力头，简单地平均注意力会导致这种能力受到抑制 具体步骤：\n线性投影：对于输入的 Q,K,V，MHA 使用不同的、可学习的线性投影投影 h 次到 $d_{k},d_{k},d_{v}$ 维。 并行注意力：对于这 h 组投影后的 Q,K,V，并行地执行注意力函数(SDPA)。Transformer模型中通常会将每个头的维度$d_{k}$和$d_{v}$设置为模型维度$d_{model}$除以头的数量 h$d_{k}=d_{v}=\\frac{d_{model}}{k}$ 拼接和最终投影：将 h 个并行注意力函数的输出($d_{v}$维)拼接起来，形成一个维度为$h \\times d_{v}$ 的向量。最后通过，另一个学习到的线性投影矩阵$W_{O}$将这个拼接后的向量投影到最终的输出维度$d_{model}$ $$ \\begin{aligned} \u0026MultiHead(Q,K,V)=Concat(head_{1},\\dots,head_{h})W^O \\\\ \u0026where \\ head_{i}=Attention(QW_{i}^Q,KW_{i}^K,VW_{i}^V) \\tag{2} \\end{aligned} $$ 其中，线性投影都是参数矩阵.$W_{i}^Q \\in \\mathbb{R}^{d_{model} \\times d_{k}},W_{i}^Q \\in \\mathbb{R}^{d_{model} \\times d_{k}},W_{i}^V \\in \\mathbb{R}^{d_{model} \\times d_{v}},W_{i}^O \\in \\mathbb{R}^{d_{model} \\times hd_{v}}$\nReference [1]Hwcoder 的 手撕经典算法 #1 Attention篇\n",
  "wordCount" : "309",
  "inLanguage": "en",
  "datePublished": "2025-05-31T22:48:40+08:00",
  "dateModified": "2025-05-31T22:48:40+08:00",
  "author":{
    "@type": "Person",
    "name": "Sage"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/attention/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sage's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Sage&#39;s Blog (Alt + H)">Sage&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Attention
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2025-05-31 22:48:40 +0800 CST'>May 31, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Sage

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6" aria-label="为什么需要注意力机制">为什么需要注意力机制</a></li>
                <li>
                    <a href="#%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6%e7%9a%84%e5%85%b7%e4%bd%93%e8%bf%90%e4%bd%9c" aria-label="注意力机制的具体运作">注意力机制的具体运作</a></li>
                <li>
                    <a href="#%e7%bc%a9%e6%94%be%e7%82%b9%e7%a7%af%e6%b3%a8%e6%84%8f%e5%8a%9bsdpa" aria-label="缩放点积注意力(SDPA)">缩放点积注意力(SDPA)</a></li>
                <li>
                    <a href="#%e5%a4%9a%e5%a4%b4%e6%b3%a8%e6%84%8f%e5%8a%9b" aria-label="多头注意力">多头注意力</a></li>
                <li>
                    <a href="#reference" aria-label="Reference">Reference</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>此处提供一张思维导图。
<img alt="Attention-Mind-Map.png" loading="lazy" src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/Attention-Mind-Map.png">
(Generated by NoteBookLLM)</p>
<h1 id="为什么需要注意力机制">为什么需要注意力机制<a hidden class="anchor" aria-hidden="true" href="#为什么需要注意力机制">#</a></h1>
<p>传统的 Seq2Seq 模型(此处以 RNN 的 Encoder - Decoder 模型为例)，会将输入序列压缩为一个定长的向量，解码器再从这个向量生成输出序列。但是定长的向量难以有效编码所有必要的信息，那么就成为了处理长句子的瓶颈。</p>
<h1 id="注意力机制的具体运作">注意力机制的具体运作<a hidden class="anchor" aria-hidden="true" href="#注意力机制的具体运作">#</a></h1>
<p>注意力机制将输入编码成一个向量序列(annotations)。在生成输出序列的每个词的时候，模型会软搜索输入序列中的相关位置，根据这些相关的上下文向量和之前已经生成的目标词来预测下一个目标词。</p>
<h1 id="缩放点积注意力sdpa">缩放点积注意力(SDPA)<a hidden class="anchor" aria-hidden="true" href="#缩放点积注意力sdpa">#</a></h1>
<p>$$
Atten(Q,K,V)=softmax\left( \frac{QK^T}{\sqrt{ d_{k} }} \right)V \tag{1}
$$</p>
<ul>
<li>注意力机制的核心在于计算一个上下文向量$(Atten(Q,K,V))$，这个向量是输入序列的加权和，权重反应了输入序列中每个部分对于生成序列当前输出词的重要性。</li>
<li>在Scaled Dot-Product Attention 中，首先计算 query 和 key 的关联性，然后将这个关联性作为value 的权重，各个权重与 value 的乘积相加得到输出。(公式 1)</li>
<li>$\sqrt{ d_{k} }$作用是缩放注意力分数。因为当$d_{k}$很大的时候，点积$QK^T$的结果会很大，导致 Softmax 产生极度不均匀的分布，梯度会变得很小。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">torch</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ScaledDotProductAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">super</span><span class="p">(</span><span class="n">ScaledDotProductAttention</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">causal_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">padding_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">        Single-head Scaled Dot-Product Attention
</span></span></span><span class="line"><span class="cl"><span class="s2">        Args:
</span></span></span><span class="line"><span class="cl"><span class="s2">            query: Query tensor of shape (batch_size, seq_len_q, d_k)
</span></span></span><span class="line"><span class="cl"><span class="s2">            key: Key tensor of shape (batch_size, seq_len_k, d_k)
</span></span></span><span class="line"><span class="cl"><span class="s2">            value: Value tensor of shape (batch_size, seq_len_v, d_v)
</span></span></span><span class="line"><span class="cl"><span class="s2">            causal_mask: Optional causal mask tensor of shape (batch_size, seq_len_q, seq_len_k)
</span></span></span><span class="line"><span class="cl"><span class="s2">            padding_mask: Optional padding mask tensor of shape (batch_size, seq_len_q, seq_len_k)
</span></span></span><span class="line"><span class="cl"><span class="s2">            1. Causal mask is used to prevent attending to future tokens in the sequence.
</span></span></span><span class="line"><span class="cl"><span class="s2">            2. Padding mask is used to ignore padding tokens in the sequence.
</span></span></span><span class="line"><span class="cl"><span class="s2">            3. Both masks are optional and can be None.
</span></span></span><span class="line"><span class="cl"><span class="s2">        Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">            attention_output: Attention weighted output tensor of shape (batch_size, seq_len_q, d_v)
</span></span></span><span class="line"><span class="cl"><span class="s2">        &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="n">d_k</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Hidden size of the key/query</span>
</span></span><span class="line"><span class="cl">        <span class="n">attention_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="n">key</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">d_k</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">causal_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">attention_scores</span> <span class="o">=</span> <span class="n">attention_scores</span><span class="o">.</span><span class="n">masked_fill</span><span class="p">(</span><span class="n">causal_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">padding_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">attention_scores</span> <span class="o">=</span> <span class="n">attention_scores</span><span class="o">.</span><span class="n">masked_fill</span><span class="p">(</span><span class="n">padding_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">attention_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">attention_scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">attention_output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attention_weights</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">attention_output</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_len</span> <span class="o">=</span> <span class="mi">16</span>
</span></span><span class="line"><span class="cl">    <span class="n">hidden_size</span> <span class="o">=</span> <span class="mi">64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">query</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">seq_len</span><span class="p">,</span><span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">key</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">seq_len</span><span class="p">,</span><span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">value</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">seq_len</span><span class="p">,</span><span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sdpa</span> <span class="o">=</span> <span class="n">ScaledDotProductAttention</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">output</span> <span class="o">=</span> <span class="n">sdpa</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Query shape:&#34;</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Key shape:&#34;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Value shape:&#34;</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Output shape:&#34;</span><span class="p">,</span> <span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">test</span><span class="p">()</span>
</span></span></code></pre></div><h1 id="多头注意力">多头注意力<a hidden class="anchor" aria-hidden="true" href="#多头注意力">#</a></h1>
<p>Transformer 是完全基于注意力机制的新架构，放弃了循环和卷积，使用多头注意力(Multi-Head Attention)(MHA)。</p>
<p>MHA 的基本思想是并行地执行多次注意力函数(SDPA)。</p>
<ul>
<li>好处是允许模型在不同的表示子空间中共同关注来自不同位置的信息</li>
<li>只是用一个注意力头，简单地平均注意力会导致这种能力受到抑制</li>
</ul>
<p>具体步骤：</p>
<ol>
<li>线性投影：对于输入的 Q,K,V，MHA 使用不同的、可学习的线性投影投影 h 次到 $d_{k},d_{k},d_{v}$ 维。</li>
<li>并行注意力：对于这 h 组投影后的 Q,K,V，并行地执行注意力函数(SDPA)。Transformer模型中通常会将每个头的维度$d_{k}$和$d_{v}$设置为模型维度$d_{model}$除以头的数量 h$d_{k}=d_{v}=\frac{d_{model}}{k}$</li>
<li>拼接和最终投影：将 h 个并行注意力函数的输出($d_{v}$维)拼接起来，形成一个维度为$h \times d_{v}$ 的向量。最后通过，另一个学习到的线性投影矩阵$W_{O}$将这个拼接后的向量投影到最终的输出维度$d_{model}$</li>
</ol>

$$
\begin{aligned}
&MultiHead(Q,K,V)=Concat(head_{1},\dots,head_{h})W^O \\
&where \ head_{i}=Attention(QW_{i}^Q,KW_{i}^K,VW_{i}^V)
\tag{2}
\end{aligned}
$$

<p>其中，线性投影都是参数矩阵.$W_{i}^Q \in \mathbb{R}^{d_{model} \times d_{k}},W_{i}^Q \in \mathbb{R}^{d_{model} \times d_{k}},W_{i}^V \in \mathbb{R}^{d_{model} \times d_{v}},W_{i}^O \in \mathbb{R}^{d_{model} \times hd_{v}}$</p>
<h1 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h1>
<p>[1]<a href="https://hwcoder.top/Manual-Coding-1">Hwcoder 的 手撕经典算法 #1 Attention篇</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="http://localhost:1313/posts/exp-migrate-from-hexo-to-hugo/">
    <span class="title">Next »</span>
    <br>
    <span>Exp Migrate From Hexo to Hugo</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Sage&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
